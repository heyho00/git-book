# 3. React

## 학습 키워드

* React란?
* 컴포넌트
* 리렌더링
* IoC(Inversion of Control)
* Library vs Framework

<br>

## rerender

트리의 같은 위치에 있는 엘리먼트 타입이 이전 렌더링과 다음 렌더링 사이에 일치하면

 React는 기존 호스트 객체를 다시 사용.


```js
// let domNode = document.createElement('button');
// domNode.className = 'blue';
// domContainer.appendChild(domNode);
ReactDOM.render(
  <button className="blue" />,
  document.getElementById('container')
);

// 호스트 객체를 다시 사용할 수 있을까요? 네! (button → button)
// domNode.className = 'red';
ReactDOM.render(
  <button className="red" />,
  document.getElementById('container')
);

// 호스트 객체를 다시 사용할 수 있을까요? 아뇨! (button → p)
// domContainer.removeChild(domNode);
// domNode = document.createElement('p');
// domNode.textContent = 'Hello';
// domContainer.appendChild(domNode);
ReactDOM.render(
  <p>Hello</p>,
  document.getElementById('container')
);

// 호스트 객체를 다시 사용할 수 있을까요? 네! (p → p)
// domNode.textContent = 'Goodbye';
ReactDOM.render(
  <p>Goodbye</p>,
  document.getElementById('container')
);
```

<br>

## 제어의 역전

왜 직접 컴포넌트를 호출하지 않는 거지? 왜 `Form()` 대신 `<Form />`이라고 써야 하는 거야? 

React는 React가 컴포넌트에 대해 아는 것이 재귀적으로 호출한 React 엘리먼트 트리만 보는 것보다 효율적으로 처리할 수 있다.

```js
// 🔴 React는 Layout이나 Article이 존재하는지 모릅니다.
// 컴포넌트를 직접 호출합니다.
ReactDOM.render(
  Layout({ children: Article() }),
  domContainer
)

// ✅ React는 Layout과 Article의 존재를 알게 됩니다.
// React가 컴포넌트를 호출합니다.
ReactDOM.render(
  <Layout><Article /></Layout>,
  domContainer
)
```

1. 컴포넌트는 함수 이상의 역할을 한다.
    react는 상호 작용에 대한 응답으로 UI트리를 렌더한다. 
    컴포넌트를 직접 호출하면 이 기능을 직접 구축해야한다.
    추상화를 제공한다고 볼 수 있다.

2. 컴포넌트 타입으로 재조정.
    트리의 개념 구조를 더 많이 알려줄 수 있다.

3. react가 재조정을 지연할 수 있다.
    브라우저가 컴포넌트 호출 사이에서 일부 작업을 할 수 있게되어 큰 컴포넌트 트리를 다시 렌더링 하더라도
    *메인 스레드를 멈추지 않게 할 수 있다.* 이를 수동으로 조율할 필요없다.

4. 디버깅
    컴포넌트가 일급 객체라면 나은 개발 도구를 만들 수 있다.

마지막 이점은 *지연 평가*이다.

## 지연평가

```js
// (2) 나중에 계산됩니다.
eat(
  // (1) 먼저 계산됩니다.
  prepareMeal()
);
```

컴포넌트로 표현하면 자바스크립트 어딘가에서 사용되기 전까지 실행되지 않는다.

조건에 따라 함수를 일찍 종료시킬 수 있다.

```js
function Page({ user, children }) {
  if (!user.isLoggedIn) {
    return <h1>Please log in</h1>;
  }
  return (
    <Layout>
      {children}
    </Layout>
  );
}
```

함수를 직접 호출하면 page 컴포넌트가 그리길 원치 않아도 즉시 실행됨.

```js
// {
//   type: Page,
//   props: {
//     children: Comments() // 항상 실행됩니다!
//   }
// }
<Page>
  {Comments()}
</Page>
```

결론적으로 컴포넌트로 작성하면 react가 호출 시점을 결정할 수 있다.

불필요한 렌더링을 피하고 코드의 취약성을 줄일 수 있다.

https://overreacted.io/ko/react-as-a-ui-runtime/